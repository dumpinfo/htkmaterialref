            HTK识别器的建立和使用--第二步：创建单音子HMM模型
            
  这一部分介绍了如何建立一套训练好的单音子HMM模型，这些模型的概率分布为高
斯分布，假设它们的均值和方差都相同。重新训练后，停顿模型将加入，sil模型
也会有些扩展。另外要注意的是，某些单词在词典中的发音有多个，而用HLED把单
词层次的MLF转换到音子层次的MLF时，它只是随意地选择所找到的第一个发音。所
以，我们还需要创建新的MLF来重估单音子HMM，这时的发音选择就由声学特征来决
定。

Step 6. 创建初步的单音子HMM模型
  第一步是要定义一个原型模型。这个模型的参数并不重要，重要的是定义这个模
型的拓扑结构。基于音子的系统的拓扑是三状态从左到右无跳转结构：
    ~o <VecSize> 39 <MFCC_0_D_A>
    ~h "proto"
    <BeginHMM>
     <NumStates> 5
     <State> 2
        <Mean> 39
          0.0 0.0 0.0 ...
        <Variance> 39
          1.0 1.0 1.0 ...
     <State> 3
        <Mean> 39
          0.0 0.0 0.0 ...
        <Variance> 39
          1.0 1.0 1.0 ...
     <State> 4
        <Mean> 39
          0.0 0.0 0.0 ...
        <Variance> 39
          1.0 1.0 1.0 ...
     <TransP> 5
      0.0 1.0 0.0 0.0 0.0
      0.0 0.6 0.4 0.0 0.0
      0.0 0.0 0.6 0.4 0.0
      0.0 0.0 0.0 0.7 0.3
      0.0 0.0 0.0 0.0 0.0
    <EndHMM>
有省略号的向量的长度都是39，这个数字是由Mel倒谱系数13个加上增量系数（一阶
差分项）13个再加上加速系数（二阶差分项）13个得来的。
  HCOMPV是HTK的工具之一，它通过扫描一系列语音数据文件，计算出全局的平均值
和方差，然后将给定的HMM中所有的高斯变量都设置为相同的均值和方差。如果假设
训练数据文件的列表都存储在train.scp中，则HCOMPV的命令格式为：
      HCompV -C config -f 0.01 -m -S train.scp -M hmm0 proto
此命令将在目录hmm0下建立新的原型proto，而它以前的零均值和单位方差也将被由
计算得到的全局平均值和方差所代替。这个原型HMM把参数种类定义为MFCC_0_D_A，
意味着除了在编码过程中计算得到的13个mel倒谱系数以外，还必须计算出它的13个
一阶差分项和13个二阶差分项并附加进来，因此config文件中TARGETKIND一项必须
更改为：TARGETKIND = MFCC_0_D_A 。选项-f 0.01将产生一个叫vFloors的宏，它
是一个向量，其值是全局方差的0.01倍，这个宏在后来的步骤中会被用来在方差的
估计中设置基底。-m选项则是要求计算均值和方差。
  在给定存储在hmm0目录下的新的原型以后，我们要手工创建一个名为hmmdefs的
MMF（Master Macro File)文件，把需要的单音子HMM加进去并重新标注，MMF和MLF
格式差不多。在hmm0目录下，还存在一个名为macro的文件。它包含了一个所谓的全
局选项宏（~o开头的那部分）和方差基底宏vFloors（~v开头的那部分），全局选项
宏也就是简单定义了HMM参数向量的种类和其长度。这两个文件的形式举例如下：
      macro                            hmmdefs
      
~o                                 -h  "aa"
    <VecSize> 39                       <BeginHMM> ...
    <MFCC_0_D_A>                       <EndHMM>
~v  "varFloor1"                    -h  "eh"
    <Variance> 39                      <BeginHMM> ...
          0.0012 0.0013 ...            <EndHMM>
                                   ... etc

  hmm0目录下的单音子HMM模型显然需要进行重估，调用工具HEREST如下：
   HERest -C config -I phones0.mlf -t 250.0 150.0 1000.0 \
    -S train.scp -H hmm0/macros -H hmm0/hmmdefs -M hmm1 monophones0
这个命令载入了hmm0目录下的所有列在monophones0这个列表文件里的HMM模型，利
用train.scp里的数据重估，新的模型将存在hmm1目录下。我们曾在step2中生成过
monophones1这个列表文件，现在的monophones0只是比它少了停顿（sp）模型。而
phones0.mlf则是在step4生成的音子层次的mlf转换文件。-t选项是在训练时设置
修剪阈值的。修剪可以限制在前向-后向算法中状态定位的范围，减少一个数
量级的运算。对大多数训练数据文件来说，一个紧凑的修剪设置是可以接受的。然
而，有些训练文件提供的声学匹配很少，所以，最终还是要定义一个比较宽的范围。
不过，HEREST提供了一个灵活的自增加的修剪设置。如上所示，通常的修剪值定在
250，如果碰到某些特别的文件，这个值太小，那么就增加150，再处理，就这样一
直下去，直到处理成功或者是修剪值超过最高限定值1000。这种防止可以让我们修
复训练数据文件的错误（代表性的错误便是产生于错误的转换）或者丢弃错误文件。
HEREST每执行一次就进行一次重估，为了得到一个好的模型，需要进行两次甚至更
多的重估，每一次都要准备一个新的目录来存储新的输出，而每次的输入自然也要
更新，这个过程要直到你满意为止，那么最新的那个目录下存放的hmmdefs文件就
是你以后要用到的HMM模型定义，一般到hmm3就可以了。

Step 7. 确定静音模型（sil）
  静音的HMM模型和其他HMM模型一样，都是三个状态从左到右的结构。我们要做的
是为模型的状态之间加上其他特别的转换，主导思想是要让各个状态能够吸收各种
各样的脉冲噪音，从而使模型具有更好的鲁棒性。为此，我们还要创建一个状态的
停顿模型（sp），它有一个从入口节点到出口节点的直接跳转，而且发射状态是和
sil模型的中心状态约束在一起的。
  这些静音模型的创建要分两步：
----对hmm3目录下的hmmdefs利用文本编辑器，拷贝sil模型的中心状态，创建一个
新的sp模型，把包含它的新的MMF文件hmmdefs放到新的目录hmm4下
----运行HMM编辑器HHED，加上所需要的状态转换，并把sp的状态和sil的中心状态
约束在一起
  HHED和HLED的命令格式差不多，它也是利用脚本中的一系列命令来修改HMM，在这
个例子中，它的格式如下：
  HHEd -H hmm4/macros -H hmm4/hmmdefs -M hmm5 sil.hed monophones1
sil.hed就是脚本文件，它包含如下命令：
  AT 2 4 0.2 {sil.transP}
  AT 4 2 0.2 {sil.transP}
  AT 1 3 0.3 {sp.transP}
  TI silst {sil.state[3],sp.state[2]}
很明显，AT是用来增加状态转换的，TI是用来设定状态之间的约束关系的。在这里，
它创建了一个约束状态silst，这个约束状态的参数将被写入hmmdefs，hmmdefs中
的每一个sil模型的最初的状态参量都会被这个宏的名字所代替。以后我们会仔细地
描述这个宏的，现在只要把它简单地看成是HTK实现参数共享的一个机制就可以了。
由于停顿模型已建好，所以我们在这里用的音子列表文件是包含sp的monophones1。
  最后，我们还要使用两次HEREST命令来重估在单词之间加入停顿（sp）的HMM模型，
这将使最新的目录变为hmm7。

Step 8. 重新校准训练数据
  开始曾经提到过，某些单词在词典里是有多个发音的，为了解决这个问题，我们
需要利用HTK识别工具HVITE来重新校准训练数据，创建新的音子转换：
  HVite -l '*' -o SWT -b silence -C config -a -H hmm7/macros \
          -H hmm7/hmmdefs -i aligned.mlf -m -t 250.0 -y lab \
          -I words.mlf -S train.scp  dict monophones1
这个命令用存储在dict中的单词发音把单词层次的words.mlf转换成新的音子层次的
aligned.mlf。这一次的转换和开始用HLED实现的那步转换有着关键性的区别，就是
识别器能够考虑到单词的所有发音，并输出和声学数据最匹配的那个。
    选项-b silence是用来在句子的开头和结尾插入静音模型的，不过这是基于词
典dict上包含有入口 silence sil 的假设之上的。选项-o是用来取消如得分，单词
名称和时间边界等在产生的MLF文件中的输出的。新的MLF文件产生后，还要再调用
工具HEREST两次，目录也变为hmm9了。